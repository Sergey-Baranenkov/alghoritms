;+--------------------------------------------------------------------------
; Эта TSR программа при нажатии F12 выводит окно с именем последней 
; запущенной программы и количеством клавиш, нажатых во время ее выполнения 

; выгрузка:
; >имяпрог /off (например: lab2 /off)
;+--------------------------------------------------------------------------

code_seg segment
        ASSUME  CS:CODE_SEG,DS:code_seg,ES:code_seg
		org 100h
		
		
start:
    jmp begin
;----------------------------------------------------------------------------
int_2Fh_vector  DD  ?
old_09h         DD  ?
old_21h         DD  ?
;----------------------------------------------------------------------------
flag       		DB  0
high_Y      	DB  5						; координаты окна
left_X      	DB  50						; координаты окна
low_Y       	DB  6						; координаты окна
right_X     	DB  75						; координаты окна
;
page_num    	DB  0
coord_Y     	DB  6						; Y координата количества нажатых клавиш в окне
coord_X     	DB  51						; X координата количества нажатых клавиш в окне
coordnewprog_y 	DB 	5 
coordnewprog_x 	DB 	51
SIZES			DW	5
BUFFER			DW	0						; Сообщение выводимое в окно
String1			DB 	'Presses:',5 dup (0) 	; Резервируем 5 байт для строки
newprogname 	DB 	'Name:',20 dup (0)  	; Имя последней запущенной программы
len 			DW 	0 						; Длина строки
;============================================================================
new_09h proc far 		;Обработчик прерывания 09h
;
    pushf
	push    AX
    in      AL,60h      ; Введем scan-code
    cmp     AL,58h      ; Это скен-код <F12>
    je      hotkey      ; Yes
	and AL,10000000b  	; Тк коды отжатых клавишь больше нажатых на 1 байт, то уберем их, наложив маску 
	cmp Al,10000000b
	je sys
	
	mov AX,CS:BUFFER
	inc AX              ; Увеличиваем число нажатий 
	mov CS:BUFFER,AX
	JMP FAR PTR 0FFFFh:0
	sys:
    pop     AX          ; No. Восстановим AX
	popf
    jmp     dword ptr CS:[old_09h]  ; В системный обработчик без возврата
hotkey:
    sti                 ; Не будем мешать таймеру
    in      AL,61h      ; Введем содержимое порта B
    or      AL,80h      ; Установим старший бит
    out     61h,AL      ; и вернем в порт B.
    and     AL,7Fh      ; Снова разрешим работу клавиатуры,
    out     61h,AL      ; сбросив старший бит порта B.
;
;-------------------- Вывод окна средствами BIOS ---------------------------
    push    BX	; сохранение используемых регистров в стеке
    push    CX	; сохранение используемых регистров в стеке
    push    DX	; сохранение используемых регистров в стеке
	push	DS	; сохранение используемых регистров в стеке
	push    DI  ; сохранение используемых регистров в стеке
	push	CS	; настройка DS
	pop		DS	;				на наш сегмент, т.е DS=CS
;----------------------------------------------------------------------------
    mov     AX, 0600h      	  ; Задание окна
    mov     BH, 05Fh          ; Белый по пурпурному
    mov     CH, CS:high_Y     ; Ко-
    mov     CL, CS:left_X     ;    ор-
    mov     DH, CS:low_Y      ;       ди-
    mov     DL, CS:right_X    ;          наты окна
    int 10h
; ------------------------ Позиционируем курсор -----------------------------
    mov     AH,02h          ; Функция позиционирования
    mov     BH,CS:page_num  ; Видеостраница
    mov     DH,CS:coord_Y   ; Строка
    mov     DL,CS:coord_X   ; Столбец
    int 10h
; ------------------------  Переводим число из BUFFER в 10 формат -----------------------------		
    mov AX,BUFFER	        ; Заносим в	AX число для перевода в 10 формат
	mov	CX,10               ; Задается делителем CX = 10
	mov DI,SIZES            ; В di Лежит номер последнего символа строки
	dec DI
Repeat:
	xor	 DX,DX            	; Обнуляем DX (для деления)
	div	 CX               	; Делим DX:AX на CX (10),Получаем в AX частное, в DX остаток
	xchg AX,DX        		; Меняем их местами (нас интересует остаток)
	add	 AL,'0'          	; Получаем в AL символ десятичной цифры
	mov  [String1+DI+8],AL  ; И записываем ее в строку
	xchg AX,DX         		; Восстанавливаем AX (частное)
	dec  DI                 ; Уменьшаем указатель
	or   AX,AX          	; Сравниваем AX с 0
	jne	 Repeat         	; Если не ноль, то повторяем
	
; ------------------------ Вывод строки с количеством нажатых клавиш на экран -----------------------------		
    mov  CX,CS:SIZES
	add  CX,8
    mov  BX, offset	CS:String1 
    mov  AH,0Eh	            ;По одному символу
next_sym:
	mov     AL,CS:[BX]	    ; Символ в AL
	inc     BX			    ; Сдвиг по строке
	cmp AL,0                ; Не будем печатать нули, при небольшом количестве нажатий клавиш
	je @ll
	int     10h		               
	@ll:
    loop    next_sym		; Цикл по строке
	
; ------------------------ Печать имени последней запущенной программы -----------------------------
; ------------------------ Позиционируем курсор -----------------------------
    mov     AH,02h          	   ; Функция позиционирования
    mov     BH,CS:page_num  	   ; Видеостраница
    mov     DH,CS:coordnewprog_y   ; Строка
    mov     DL,CS:coordnewprog_x   ; Столбец
    int 10h
;------------------------- Распечатаем имя этой программы--------------------
	mov     CX,len
	add 	CX,5				   ;Длина "Name" 
    mov     BX,offset CS:newprogname 
    mov     AH,0Eh	               ;По одному символу
next_sym2:
	mov     AL,CS:[BX]		       ; Символ	в AL		           
	inc     BX					   ; Сдвиг по строке
	int     10h	
    loop    next_sym2		       ; Цикл по строке
; восстановление регистров из стека в порядке LIFO
	pop 	DI
	pop		DS	
    pop     DX
    pop     CX
    pop     BX
;---------------------------------------------------------------------------
    cli
    mov     AL, 20h      ; Пошлем
    out     20h,AL       ; приказ EOI
;
    pop     AX
	popf
    iret
new_09h     endp
;===========================================================================
new_21h proc far
    pushf  ; сохраняем флаги
    cmp   AH, 4Bh ;4Bh - функция запуска новой программы
    je    newprog ; Да? прыгаем на новый обработчик
    popf   ; иначе восстанавливаем флаги (которые изменял cmp)
    jmp   dword ptr CS:[old_21h]  ; прыгаем в системный обработчик без возврата
newprog:

	push ax bx cx dx ds si DI ES; сохраняем все используемые регистры в стеке

	push dx;  заносим в регистр SI сегмент, в котором

	pop si; - содержится имя запускаемой программы

	mov bx,0; обнуляем регистр BX (для длины)
	mov CS:BUFFER,0
	
	mov cx,5
	mov di,8; Не учитываем Presses
	oblulenie:
	mov CS:String1[di],0 ;Если новая запущенная программа обнуляем предыдущее количество нажатий
	inc di
	loop oblulenie

m1:
	mov al,ds: [si+bx] ; 
	mov cs: newprogname [bx+5],al; ¦ копируем имя программы в переменную
	inc bx; 
	cmp al,0; конец строки завершается нуликом
	jnz m1
	mov cs: len,bx; сохраняем длину строки	
    pop ES DI SI DS DX CX BX AX ;восстанавливаем регистры
    popf        ; не забываем флаги, которые сохраняли в самом начале
	jmp   dword ptr CS:[old_21h]
    iret
new_21h endp
;============================================================================
int_2Fh proc far
    cmp     AH,0C7h         ; Наш номер?
    jne     Pass_2Fh        ; Нет, на выход
    cmp     AL,00h          ; Подфункция проверки на повторную установку?
    je      inst            ; Программа уже установлена
    cmp     AL,01h          ; Подфункция выгрузки?
    je      unins           ; Да, на выгрузку
    jmp     short Pass_2Fh  ; Неизвестная подфункция - на выход
inst:
    mov     AL,0FFh         ; Сообщим о невозможности повторной установки
    iret
Pass_2Fh:
    jmp dword PTR CS:[int_2Fh_vector]
;
; -------------- Проверка - возможна ли выгрузка программы из памяти ? ------
unins:
    push    BX
    push    CX
    push    DX
    push    ES
    mov     CX,CS   ; Пригодится для сравнения, т.к. с CS сравнивать нельзя
	
; Обработчик 21 прерывания
	mov 	AX,3521h
	int     21h
;
	mov DX,ES 
	cmp CX,DX
	jne Not_remove
;
	cmp BX, offset CS:new_21h
	jne Not_remove
;
    mov     AX,3509h    ; Проверить вектор 09h
    int     21h 		; Функция 35h в AL - номер прерывания. Возврат-вектор в ES:BX
;
    mov     DX,ES
    cmp     CX,DX
    jne     Not_remove
;
    cmp     BX, offset CS:new_09h
    jne     Not_remove

    mov     AX,352Fh    ; Проверить вектор 2Fh
    int     21h 		; Функция 35h в AL - номер прерывания. Возврат-вектор в ES:BX
;
    mov     DX,ES
    cmp     CX,DX
    jne     Not_remove
;
    cmp     BX, offset CS:int_2Fh
    jne     Not_remove
; ---------------------- Выгрузка программы из памяти ---------------------
;
    push    DS
;
	lds     DX,CS:old_21h   ; Эта команда эквивалентна следующим двум
	;mov     DX, word ptr old_21h
    ;mov     DS, word ptr old_21h+2
	mov AX, 2521h           ; Заполнение вектора старым содержимым
	int 21h
;
    lds     DX, CS:old_09h  ; Эта команда эквивалентна следующим двум
;    mov     DX, word ptr old_09h
;    mov     DS, word ptr old_09h+2
    mov     AX,2509h        ; Заполнение вектора старым содержимым
    int     21h

;   
    lds     DX, CS:int_2Fh_vector   ; Эта команда эквивалентна следующим двум
;    mov     DX, word ptr int_2Fh_vector
;    mov     DS, word ptr int_2Fh_vector+2
    mov     AX,252Fh
    int     21h
;
    pop     DS
;
    mov     ES,CS:2Ch       ; ES -> окружение
    mov     AH, 49h         ; Функция освобождения блока памяти
    int     21h
;
    mov     AX, CS
    mov     ES, AX          ; ES -> PSP выгрузим саму программу
    mov     AH, 49h         ; Функция освобождения блока памяти
    int     21h
;
    mov     AL,0Fh          ; Признак успешной выгрузки
    jmp     short pop_ret
Not_remove:
    mov     AL,0F0h          ; Признак - выгружать нельзя
pop_ret:
    pop     ES
    pop     DX
    pop     CX
    pop     BX
;
    iret
int_2Fh endp
;============================================================================
begin:
        mov CL,ES:80h       ; Длина хвоста в PSP
        cmp CL,0            ; Длина хвоста=0?
        je  check_install   ; Да, программа запущена без параметров,
                            ; попробуем установить
        xor CH,CH       ; CX=CL= длина хвоста
        cld             ; DF=0 - флаг направления вперед
        mov DI, 81h     ; ES:DI-> начало хвоста в PSP
        mov SI,offset key   ; DS:SI-> поле key
        mov AL,' '          ; Уберем пробелы из начала хвоста
repe    scasb   ; Сканируем хвост пока пробелы
                ; AL - (ES:DI) -> флаги процессора
                ; повторять пока элементы равны
        dec DI          ; DI-> на первый символ после пробелов
        mov CX, 4       ; ожидаемая длина команды
repe    cmpsb   ; Сравниваем введенный хвост с ожидаемым
                ; (DS:DI)-(ES:DI) -> флаги процессора
        jne check_install ; Неизвестная команда - попробуем установить
        inc flag_off
; Проверим, не установлена ли уже эта программа
check_install:
        mov AX,0C700h   ; AH=0C7h номер процесса C7h
                        ; AL=00h -дать статус установки процесса
        int 2Fh         ; мультиплексное прерывание
        cmp AL,0FFh
        je  already_ins ; возвращает AL=0FFh если установлена
;----------------------------------------------------------------------------
    cmp flag_off,1
    je  xm_stranno
;----------------------------------------------------------------------------
    mov AX,352Fh                      ;   получить
                                      ;   вектор
    int 21h                           ;   прерывания  2Fh
    mov word ptr int_2Fh_vector,BX    ;   ES:BX - вектор
    mov word ptr int_2Fh_vector+2,ES  ;
;
    mov DX,offset int_2Fh           ;   получить смещение точки входа в новый
                                    ;   обработчик на DX
    mov AX,252Fh                    ;   функция установки прерывания
                                    ;   изменить вектор 2Fh
    int 21h  ; AL - номер прерыв. DS:DX - указатель программы обработки прер.
;============================================================================
    mov AX,3509h                        ;   получить
                                        ;   вектор
    int 21h                             ;   прерывания  09h
    mov word ptr old_09h,BX    ;   ES:BX - вектор
    mov word ptr old_09h+2,ES  ;
    mov DX,offset new_09h           ;   получить смещение точки входа в новый
;                                   ;   обработчик на DX
    mov AX,2509h                        ;   функция установки прерывания
                                        ;   изменить вектор 09h
    int 21h ;   AL - номер прерыв. DS:DX - указатель программы обработки прер.
;============================================================================
	mov AX,3521h                        ;   получить
                                        ;   вектор
    int 21h                             ;   прерывания  21h
    mov word ptr old_21h,BX    ;   ES:BX - вектор
    mov word ptr old_21h+2,ES  ;
    mov DX,offset new_21h           ;   получить смещение точки входа в новый
;                                   ;   обработчик на DX
    mov AX,2521h                        ;   функция установки прерывания
                                        ;   изменить вектор 21h
    int 21h ;   AL - номер прерыв. DS:DX - указатель программы обработки прер.
;============================================================================
        mov DX,offset msg1  ; Сообщение об установке
        call    print
;----------------------------------------------------------------------------
    mov DX,offset   begin           ;   оставить программу ...
    int 27h                         ;   ... резидентной и выйти
;============================================================================
already_ins:
        cmp flag_off,1      ; Запрос на выгрузку установлен?
        je  uninstall       ; Да, на выгрузку
        lea DX,msg          ; Вывод на экран сообщения: already installed!
        call    print
        int 20h
; ------------------ Выгрузка -----------------------------------------------
 uninstall:
        mov AX,0C701h  ; AH=0C7h номер процесса C7h, подфункция 01h-выгрузка
        int 2Fh             ; мультиплексное прерывание
        cmp AL,0F0h
        je  not_sucsess
        cmp AL,0Fh
        jne not_sucsess
        mov DX,offset msg2  ; Сообщение о выгрузке
        call    print
        int 20h
not_sucsess:
        mov DX,offset msg3  ; Сообщение, что выгрузка невозможна
        call    print
        int 20h
xm_stranno:
        mov DX,offset msg4  ; Сообщение, программы нет, а пользователь
        call    print       ; дает команду выгрузки
        int 20h
;----------------------------------------------------------------------------
key         DB  '/off'
flag_off    DB  0
msg         DB  'already '
msg1        DB  'installed',13,10,'$'
msg4        DB  'just '
msg3        DB  'not '
msg2        DB  'uninstalled',13,10,'$'
;============================================================================
PRINT       PROC NEAR
    MOV AH,09H
    INT 21H
    RET
PRINT       ENDP
;;============================================================================
code_seg ends
         end start